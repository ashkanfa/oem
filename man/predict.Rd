% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{predict.oemfit}
\alias{predict.cv.oem}
\alias{predict.oemfit}
\alias{predict.oemfit_binomial}
\alias{predict.oemfit_gaussian}
\title{Prediction method for Orthogonalizing EM fitted objects}
\usage{
\method{predict}{oemfit}(object, newx, s = NULL, which.model = 1,
  type = c("link", "response", "coefficients", "nonzero", "class"), ...)

\method{predict}{oemfit_gaussian}(object, newx, s = NULL, which.model = 1,
  type = c("link", "response", "coefficients", "nonzero"), ...)

\method{predict}{oemfit_binomial}(object, newx, s = NULL, which.model = 1,
  type = c("link", "response", "coefficients", "class", "nonzero"), ...)

\method{predict}{cv.oem}(object, newx, which.model = "best.model",
  s = c("lambda.1se", "lambda.min"), ...)
}
\arguments{
\item{object}{fitted "oem" model object}

\item{newx}{Matrix of new values for x at which predictions are to be made. Must be a matrix; can be sparse as in Matrix package. 
This argument is not used for type=c("coefficients","nonzero")}

\item{s}{Value(s) of the penalty parameter lambda at which predictions are required. Default is the entire sequence used to create 
the model. For predict.cv.oem, can also specify "lambda.1se" or "lambda.min" for best lambdas estimated by cross validation}

\item{which.model}{If multiple penalties are fit and returned in the same oem object, the which.model argument is used to 
specify which model to make predictions for. For example, if the oem object "oemobj" was fit with argument 
penalty = c("lasso", "grp.lasso"), then which.model = 2 provides predictions for the group lasso model. For 
predict.cv.oem, can specify
"best.model" to use the best model as estimated by cross-validation}

\item{type}{Type of prediction required. Type == "link" gives the linear predictors for the "binomial" model; for "gaussian" models it gives the fitted values. 
Type == "response" gives the fitted probabilities for "binomial". Type "coefficients" computes the coefficients at the requested values for s.
Type "class" applies only to "binomial" and produces the class label corresponding to the maximum probability.}

\item{...}{not used except for predict.cv.oem, in which case it is used to pass the other arguments for predict.oemfit}
}
\value{
An object depending on the type argument
}
\description{
Prediction method for Orthogonalizing EM fitted objects
}
\examples{
set.seed(123)
n.obs <- 1e4
n.vars <- 100
n.obs.test <- 1e3

true.beta <- c(runif(15, -0.5, 0.5), rep(0, n.vars - 15))

x <- matrix(rnorm(n.obs * n.vars), n.obs, n.vars)
y <- rnorm(n.obs, sd = 3) + x \%*\% true.beta
x.test <- matrix(rnorm(n.obs.test * n.vars), n.obs.test, n.vars)
y.test <- rnorm(n.obs.test, sd = 3) + x.test \%*\% true.beta

fit <- oem(x = x, y = y, 
           penalty = c("lasso", "grp.lasso"), 
           groups = rep(1:10, each = 10), 
           nlambda = 10)

preds.lasso <- predict(fit, newx = x.test, type = "response", which.model = 1)
preds.grp.lasso <- predict(fit, newx = x.test, type = "response", which.model = 2)

apply(preds.lasso,     2, function(x) mean((y.test - x) ^ 2))
apply(preds.grp.lasso, 2, function(x) mean((y.test - x) ^ 2))

set.seed(123)
n.obs <- 1e4
n.vars <- 100
n.obs.test <- 1e3

true.beta <- c(runif(15, -0.5, 0.5), rep(0, n.vars - 15))

x <- matrix(rnorm(n.obs * n.vars), n.obs, n.vars)
y <- rnorm(n.obs, sd = 3) + x \%*\% true.beta
x.test <- matrix(rnorm(n.obs.test * n.vars), n.obs.test, n.vars)
y.test <- rnorm(n.obs.test, sd = 3) + x.test \%*\% true.beta

fit <- cv.oem(x = x, y = y, 
              penalty = c("lasso", "grp.lasso"), 
              groups = rep(1:10, each = 10), 
              nlambda = 10)

preds.best <- predict(fit, newx = x.test, type = "response", which.model = "best.model")

apply(preds.best, 2, function(x) mean((y.test - x) ^ 2))

}

